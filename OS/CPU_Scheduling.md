# CPU 스케줄링 *Scheduling*

> CPU에서 어떤 기준으로 Process에게 CPU 제어권을 부여하는지에 대한 정책
>
> 모든 프로세스가 공평하게 작업시간을 부여하는것이 목적
>
> 안정성과 효율성을 고려하면 공평성이 낮아질 수 있음

### 목차
- 목적
- 단계
- 발생 시기
- 전략
- 프로세스 종류 CPU/IO bound / 전면/후면
- 스케줄링 알고리즘

<br/><br/>

---
## 목적

- `공평성` 모든 프로세스는 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안 됨
- `효율성` 시스템 자원을 최대한 활용하여 스케줄링
- `안정성` 우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 스케줄링 (공평성과 상충된 목적)
- `반응 시간 보장` 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 함
- `무한 연기 방지` 특정 프로세스의 작업이 무한히 연기되어서는 안됨 (공평성)

### 성능 척도
> OS의 성능 척도와 비슷함

### CPU 관점

- CPU 사용률 *CPU utilization*
  - 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법으로 최대한 CPU를 사용
  - CPU가 쉬지 않는 상태가 100% 기준
- 처리량 *Throughput*
  - 단위 시간당 작업을 수행한 프로세스의 개수 = CPU 버스트를 처리한 개수

### 사용자 관점

`반환 시간` *Trun-around time*
```
프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
대기 시간 + 실행시간
* 대기 시간은 없을 수도 있고, 1 번 or 여러 번 측정될 수 있음
```
`대기 시간` *Waiting time*
```
프로세스가 CPU를 할당받아 실행되기 전 대기하는 시간
보통 준비 큐에서 대기를 하는 시간
여러 번 측정될 수 있음
```
`응답 시간` *Response time*
```
프로세스가 대기 상태에 들어와 CPU를 최초로 얻기까지 걸리는 시간
응답 시간은 최초의 한 번을 의미

CPU를 한 번도 못 얻은 것과 한 번이라도 얻는 것은 사용자 응답에 있어서 중요한 차이가 있기 때문에 중요
```

<br/><br/>

---
## 단계

### 장기 스케줄링 *Long term scheduling*

> 작업 스케줄러
>
> 가장 큰 틀에서 이루어지는 CPU 스케줄링으로 시스템 내의 전체 작업 수를 조절
>
> Ready Queue에 삽입할 프로세스를 결정

### 중기 스케줄링 *Medium term scheduling*

> 메모리에 적재된 프로세스의 수를 동적으로 조절하는 스케줄러

### 단기 스케줄링 *Short term scheduling*

> CPU 스케줄링
>
> Ready 상태인 Process 중 어떤 Process를 다음 번에 Excute 상태로 만들 것인지를 결정
>
> 스케줄링 알고리즘에 따라 CPU 할당 대상 Process를 결정

<br/><br/>

---
## 발생 시기

- 프로세스가 입/출력을 요구할 때
- 프로세스가 종료를 요구할 때
- 높은 우선순위의 프로세스가 나타났을 때
- 주어진 CPU 실행 시간을 초과했을 때

<br/><br/>

---
## 전략

### 비선점 *Non-preemption*

> 수행 중인 프로세스가 자율적으로 CPU를 반납할 때까지 CPU를 계속 점유하여 실행하는 운영체제 환경
>
> **입/출력 (I/O bounds) 위주의 Process** ( I/O bound process ) 가 다수인경우,
>
> CPU를 어느정도 규칙적으로 번갈아 할당받을 수 있으므로 응답시간이 효율적
>
> 응답시간 예측 용이

### 선점 *Preemption*

> 자율적 CPU 반납은 물론 타율적 CPU 반납까지 이루어지는 운영체제 환경
>
> **계산 위주 프로세스** (CPU bound process) 가 다수일 경우 모든 프로세스의 반응 시간 성능을 평균 이상으로 유지 가능

### 프로세스 우선순위

- 커널 프로세스 > 일반 프로세스
- 전면 프로세스 > 후면 프로세스
- 대화형 프로세스 > 일괄 처리 프로세스
- 입출력 집중 프로세스 > CPU 집중 프로세스

<br/><br/>

---
## 스케줄링 알고리즘

| 프로세스 | CPU 버스트 시간 |
| --- | --- |
| P1 | 30 |
| P2 | 3 |
| P3 | 6 |

## 비선점

### FCFS *First Come First Served*
- Ready Queue 에 도착한 순서에 따라 순서대로 CPU 할당
- 공평성 유지 But, 효율적이지 못함
> P1 -> P2 -> P3
>
> 평균 대기 시간 = (0 + 30 + 33) / 3 = 21
>
> 평균 응답 시간 = (30 + 33+ 39) / 3 = 34

### SJF *Shortest Job First*
- CPU 사용시간이 가장 짧은 프로세스에게 우선적으로 CPU할당

> P2 -> P3 -> P1
>
> 평균 대기 시간 = (0 + 3 + 9) / 3 = 4
>
> 평균 응답 시간 = (3 + 9 + 39) / 3 = 17

### HRN
- 실행시간이 긴 프로세스가 불리한 SJF 보완
- (대기시간 + 서비스시간) / 서비스시간 의 결과값이 높은 순으로 우선순위 부여


## 선점

| 프로세스 | 도착 시간 | CPU 버스트 시간 |
| -------- | --------- | --------------- |
| P1 | 0 | 30 |
| P2 | 1 | 15 |
| P3 | 2 | 10 |

### SRTF or SRT *Shortesst Remaining Time First*
- 비선점 SJF의 단점을 보완한 선점 SJF

> P1 -> P2 -> P3 -> P2 -> P1
>
> 평균 대기 시간 = (25 + 10 + 0) / 3 = 11.7

### RR *Round Robin*
- 대표적인 선점 스케줄링 전략
- 모든 프로세스에게 동일한 점유 시간 (타임 퀀텀)을 설정 후, 해당 시간 초과시 자원을 회수하여 다음 프로세스에게 할당
- 점유 시간이 길수록 FCFS / 짧을 수록, 컨텍스트 스위칭 횟수 증가

### MQ *Multi level Queue*
- 다단계 큐
- 프로세스의 특성을 고려하지 못한 RR 방식을 보완
- 프로세스 특성별로 Ready Queue를 두어 우선순위를 부여 후, <br/>
높은 우선순위 큐들이 비어있을 경우에 다음 단계 Ready Queue Process 할당

  - 대화형 프로세스의 경우 cpu 사용 시간이 짧으므로 긴 점유 시간을 부여할 필요가 없음
  - CPU 계산 위주 프로세스일 경우 긴 점유 시간을 부여하면 스위칭 빈도가 줄어 효율을 높일 수 있음

### MFQ *Multi level Feedback Queue*
- 다단계 피드백 큐
- 프로세스 수행 중 특성이 변하면 이를 인지하여 해당 프로세스를 적절한 준비 큐로 이동시켜주는 전략

    - 실행 중인 프로세스가 해당 큐의 타임 퀀텀을 소진하지 못하고 입출력 등으로 CPU를 반납하면, <br/>
    입/출력 성향이 강해진 것으로 인식하여 입/출력 쪽으로 한 단계 높은 준비 큐로 이동
    - 실행 중인 프로세스가 주어진 타임 퀀텀을 모두 소진하여 CPU를 강제로 회수당하면, <br/>
    계산 성향이 강해진 것으로 인식하여 이 프로세스를 입/출력 성향 기준 한 단계 낮은 준비 큐로 이동

