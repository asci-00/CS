# 프로세스와 스레드
## 목차
- 프로세스와 스레드
- 주소 공간
- 멀티프로세스와 멀티스레드
- IPC
- 동기화

<br/><br/>
---

## 프로세스와 스레드
### 프로세스란?
> 1. 실행 중인 프로그램 - 디스크로부터 메모리에 적재되어 CPU 할당을 받을 수 있는 작업 단위
> 2. OS로부터 주소 공간, CPU 시간, 메모리 등의 시스템 자원을 할당받음

### **Context Switching이란?**
>
> 프로세스의 상태 정보를 PCB에 저장하고 복원하는 일련의 과정
>
> 필요 이유 : 하나의 Task를 처리하는동안 다른 Task 작업을 못하는 문제를 해결하기 위해 <br/>빠른 속도로 Task를 번갈아가며 수행하기 위함
>
> | 발생 상황 | 설명 | 전이 과정 |
> |---|---|---|
> | dispatch | Queue 우선 Process로 CPU를 할당받아 실행 상태로 전이 | 준비 -> 실행 (dispatch) |
> | CPU 할당 시간 만료 | CPU 사용 가능한 할당 시간 초과로 준비 상태로 전이 | 실행 -> 준비 (timeout) |
> | I/O 작업 및 할당 | I/O작업이 필요해 작업 완료시까지 대기 | 실행 -> 대기 (sleep) |
> | System Call | 또 다른 서비스 호출이 필요한 경우 대기 | 실행 -> 대기 (sleep) |
>
> A프로세스 -> OS -> A프로세스 전환은 문맥교환이 아님
>
> 문맥교환 절차
> 1. CPU 제어권이 실행중인 프로세스 A에서 운영체제로 이양
> 2. 동작 모드가 사용자모드에서 커널모드로 전환
> 3. 운영체제가 프로세스 A의 상태를 PCB에 저장
> 4. 다음 프로세스 B의 정보를 PCB에서 가져온 후 CPU 제어권 부여
> 5. 프로세스 A는 Excute -> Ready 상태로 전이
> 6. 동작 모드가 커널모드에서 사용자모드로 전환
>
> !프로세스가 Ready → Running, Running → Ready, Running → Waiting처럼 상태 변경 시 문맥교환 발생
>
> 기능 : Cache 초기화. Memory mapping 초기화, 커널 항시 실행
> .
> 해결 방안 : 프로그램 다중화 수준 낮춤, 스레드 이용, 스택 포인터 활용
>
> Q. 스레드가 프로세스보다 문맥교환 비용이 적은 이유는?
> A. 스레드는 Stack 영역만 고유하게 할당받으므로, Stack영역만 변경을 진행하면 되기 때문


### 특징
- PCB Process Control Block
    - 프로세스에 대한 중요한 정보를 저장하는 <b>커널 내의 자료구조</b>
    - Process 생성과 동시에 고유한 PCB를 생성
    - 문맥교환 Context Switching이 발생할 때 기존에 작업하던 내용을 PCB에 저장됨
    - 저장되는 정보
        - PID Process ID
        - 프로세스 상태 : new, ready, running, waiting, terminated
        - PC Program Counter : 다음 실행 명령어 주소
        - CPU Register
        - CPU 스케줄링 정보 : 프로세스 우선순위, 스케줄 큐에 대한 포인터 등
        - 메모리 정보 : 페이지 테이블 or 세그먼트 테이블 등
        - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
        - 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등
    - PCB는 Linked List 방식으로 관리됨(삽입 삭제가 용이)
- 각 프로세스는 Code, Data, Stack, Heap 영역을 할당받음
- 다른 프로세스의 변수나 자료구조에 접근 불가 - IPC 필요
- 아래와 같은 상태 전이도를 가짐 (활성 상태 active state)

![](http://itwiki.kr/images/d/da/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png)

    - 이 외에 비활성 상태 inactive state 두가지를 더 가짐
    - 휴식 상태 : Ctrl+Z 등의 인터럽트를 통해 잠시 멈춘 상태. 메인 메모리에 PCB가 존재하며 프로세스의 데이터도 유지됨.
    - 보류 상태
        - 메모리 초과, 오류, 바이러스, 입출력 지연 등의 이유로 Ready(준비 -> 보류 준비 상태), Wait(대기 -> 보류 대기 상태) 상태에서 보류가 발생하게 됨
        - 보류 상태가 되면 Swap 영역에 데이터가 보관됨
        - 보류 대기 상태에서 인터럽트(입출력 완료)가 발생하면 보류 준비상태로 전환된 후 Ready Queue에 삽입됨

### 스레드란?
> 1. 프로세스의 실행 단위, 작업의 흐름 단위

### 특징
- TID ThreadID, PC, Register 집합, 스택으로 구성
- 프로세스의 다른 스레드와 Code, Data, Heap을 공유 (Stack은 별도 할당)
    - 스택 : 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내 선언된 변수 등을 저장하기 위한 공간
    - 스택 메모리가 독립적일 경우 독립적 함수 호출 가능 - 독립적인 실행 흐름

## [2. 주소 공간]

![AdressSpace](https://user-images.githubusercontent.com/33534771/77537866-232c6e00-6ee2-11ea-91dc-12dacf688276.png)*[출처 : https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.md]*

- Code : 코드 자체를 구성하는 메모리 영역 - 명령어들이 저장됨<br/>
- Data : 전역변수, 정적변수, 배열 영역
    - .bbs : 초기화 되지 않은 변수
    - .data : 초기화 된 데이터
- Heap : 동적 할당된 데이터 영역
- Stack : 지역변수, 매개변수, 리턴 값 영역

> 구역이 나뉘어진 이유 : 최대한 데이터를 공유하여 메모리 사용량을 줄이기 위함 - Code 영역과 Heap, Data 영역은 공유 가능 영역

<br/><br/>
---

## 멀티프로세스와 멀티스레드
[참고](https://velog.io/@chy0428/OS-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1)

> 구형 IE와 Chrome을 비교함으로써 이해 가능

### 멀티 프로세스
> 개념 1. 하나의 컴퓨터에 여러 CPU 존재 - 하나 이상의 프로세스들을 동시에 병렬 처리<br/>
> 개념 2. 하나의 응용프로그램에서 자식 프로세스를 생성하여 여러 프로세스를 동시 수행

#### 장점
- 독립된 구조로 안전성이 높다 ( 메모리 침범 문제를 OS 차원에서 해결 )
-
#### 단점
- 각각 독립된 메모리 영역을 가지고 있어, 작업량이 많을 수록 오버헤드 발생, 문맥 교환으로 인한 성능 저하
- 메모리 공유를 위한 IPC 기법 사용 필요

### 멀티 스레드
> 하나의 프로세스에서 여러 스레드를 동시에 처리<br/>
> 공유 자원에 접근할 때, 의도한 대로 동작하는 것을 Trhead-safe 라고 표현함

#### 장점
- 시스템 자원소모 감소 (자원의 효율성 증대)
- 시스템 처리율 향상 (처리비용 감소)
    - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.
    - 스레드 사이 작업량이 작아 Context Switching이 빠르다. (캐시 메모리를 비울 필요가 없다.)
- 간단한 통신 방법으로 프로그램 응답시간 단축
#### 단점
- 안전성 문제 - 공유된 데이터 공간이 손상될 시, 해당 공간을 참조하는 다른 스레드도 작동 불능
    - Critical Section 기법을 통한 대비 ( 상호 배제, 진행, 한정된 대기를 충족 )

### 멀티 스레드 vs 멀티 프로세스
- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료 될 위험을 갖고 있다.
- 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있다.
- 두 방법은 동시에 여러 작업을 수행하는 점에서 동일하지만, 각각의 장단이 있으므로 적용하는 시스템에 따라 적합한 동작 방식을 선택하고 적용해야 한다.


<br/><br/>
---

## 동기화
### 동기화란?
> 일반적으로 프로세스(or 스레드)는 다른 프로세스와 비동기적으로 수행됨 (처리 순서가 보장되지 않음)<br/>
> 이로인해 여러 프로세스가 공통된 자원을 사용할 때, 아래와 같은 문제가 발생
> 1. 동시에 자원에 접근하여 자원을 사용하지 못하는 프로세스 발생
> 2. 동시에 데이터를 수정 조회 등의 작업을 수행할 시, 데이터의 일관성이 보장되지 않음
>
> 동기화 기법은 크게 사용자영역의 동기화 방법과 커널영역의 동기화 기법이 존재

### 임계영역 Critical Section
- 여러 작업이 공통적으로 자원에 접근하는 영역을 의미
- 해당 영역에 접근하려는 여러 작업들이 있을 때, 규칙을 적용하여 자원을 할당하면 동기화가 가능
    - 생호 배제 : 이미 프로세스가 임계영역을 점유 중일 때, 다른 프로세스는 해당 임계영역에 접근하지 못함
    - 진행 : 임계영역을 점유한 프로세스가 없을경우, 별도의 동작이 없는 프로세스는 임계영역에 진입할 수 있다.
    - 한정된 대기 : 프로세스가 임계영역에 진입을 요청 후 승인되기 전까지 다른 프로세스들이 임계영역에 진입하는 횟수는 제한되어야 함

### 동기화 기법
### 사용자 영역 동기화
> 커널의 기능을 사용하지 않는 동기화 방법  -커널 코드 사용 x<br/>
> 커널 영역 동기화보다 성능이 좋으나, 기능상 제한점이 존재<br/>
> 임계 구역 기반 동기화, 인터락 함수 기반 동기화

1. 임계 구역 기반의 동기화
    - 열쇠를 얻은 프로세스만 임계 구역에 접근 -> 한번에 하나의 스레드만이 접근 가능
    - 임계 구역 진입을 위해 크리티컬 섹션 오브젝트를 얻는다
    - 다른 프로세스가 열쇠를 가지고 있을 시에는 반환할 때까지 블로킹 - 열쇠가 반환되면 블로킹 상태에서 빠져나와 열쇠를 얻고 임계 구역에 접근
2. 인터락 함수 기반의 동기화
    - 함수 내부적으로 한 순간에 하나의 스레드에 의해서만 실행되도록 동기화
    - 임계 영역 기반의 동기화도 내부적으로 인터락 함수를 기반으로 구현
    - 사용자 영역 기반으로 동작해서 속도가 빠름

### 커널 영역 동기화
> 커널에서 제공하는 동기화 기능 사용 x<br/>
> 커널 영역에 접근해야 하므로 성능 저하가 발생<br/>
> 세마포어, 뮤텍스, 모니터 등의 기능

1. 세마포어 Semaphore
    - 공유된 자원의 개수만큼의 프로세스, 스레드만 동시에 접근할 수 있도록 제어
    - 공유 가능한 자원 갯수에 따라 다음과 같이 나뉜다.
        - 1개 : Binary Semaphore(뮤텍스와 같다.)
        - 2개 이상 : Counting Semaphore
    - P (자원 점유 요청) V (자원 반환) 연산을 가진다.
    - 세마포어는 소유할 수 없다.
    - Signaling 메커니즘 - 락을 걸지 않은 프로세스들도 signal을 사용해 락을 해제할 수 있음
    - Busy-waiting 을 보완하기 위해 큐 or 리스트를 활용할 수 있음
2. 뮤텍스 Mutal Exclusion
    - 공유된 자원을 여러 스레드 or 프로세스 가 동시에 접근하지 못하도록 제어
    - 임계 구역을 가진 프로세스들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되도록 제어
    - 뮤텍스 객체를 두 프로세스가 동시에 사용할 수 없다 (상호 배제)
    - 일종의 <b>Locking 매커니즘</b>으로 공유 자원에 대한 접근을 조율하기 위해 locking과 unlocking을 사용
    - Lock에 대한 소유권이 있으며 Lock을 가지고 있을 경우에만 공유 자원에 접근할 수 있고, Lock을 가진 프로세스만 반납 가능
    - 뮤텍스 소유 프로세스는 뮤텍스를 해제할 수 있음
3. 모니터 Monitor
    - Mutex(Lock)와 Condition Variables를 가지고 있는 Synchronization 매커니즘이다.
    - 동일 프로세스 내 스레드끼리 동기화 가능
    - 뮤텍스와 모니터는 상호 배제를 함으로써 임계 구역에 하나의 쓰레드만 들어갈 수 있다.
    - C에서 지원하지 않는다.

Q. Binary Semaphore 가 존재한다면 Mutex의 필요성이 있나?<br/>
A. 뮤텍스는 Loking 메커니즘으로 key에 대한 소유권이 존재하며, Semaphore는 

Signaling 메커니즘으로 소유권 개념이 존재하지 않는다는 차이점을 가짐<br/>

세마포어는 다른 스레드/프로세스가 세마포어 잠금 해제를 요청할 수 있으며, 뮤텍스는 

key를 획득한 스레드만 잠금을 해제할 수 있다.

대답이 이해가 안된다.. 참고[http://gauss.ececs.uc.edu/Courses/c3003/extra/difference-between-semaphore-and-mutex.html]
