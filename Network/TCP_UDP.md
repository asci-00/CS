# TCP/UDP
### 목차
- TCP와 UDP
- TCP의 동작
- UDP의 동작


## [1. TCP와 UDP]
<br/>

> 송신자와 수신자를 연결하는 통신 서비스를 제공하고 IP에 의해 전달되는 패킷의 오류를 검사하며 재전송 요구 제어등을 담당하는 전송 계층의 프로토콜 TCP/UDP
>
> 포트를 사용하여 상위 계층에 데이터 전달
>
> IP(단말기 구분) / Port(해당 단말기에서 어떤 프로세스에 전달해야되는지 구분)

## 1. TCP
> 연결 지향적 프로토콜 - 통신을 하기 위해서 두 단말기 사이가 연결된 상태여야 함
>
> 일반적으로 클라이언트 - 서버 관계로 설명됨
>
> 1. 클라이언트가 서버로 연결 요청
> 2. 서버가 연결을 수락 - 두 단말기  가상회선을 고정
> 3. 세그먼트로 분할된 데이터가 정해진 경로를 통해서 순서대로 통신됨
>

#### 특징
- 연결 지향 프로토콜
- 데이터의 경계를 구분하지 않음 (바이트 스트림)
    - 송신측에서 전송한 데이터를 수신측에서 스트림 형태로 받음 (한번 or 여러번에 거쳐서 read)
- 연결의 설정 (3-way-handshaking)과 해제 (4-way-handshaking)
- 전이중(Full-Duplex), 점대점(Point to Point) 서비스
- 일반적으로 IP 프로토콜과 같이 사용되어 IP 계층의 신뢰성 없는 서비스에 대해 신뢰성 제공

#### 장점
- 안정적이고 신뢰성 있는 데이터 전송
    - 패킷 손실, 중복, 순서바뀜 등이 없도록 보장
- 데이터 흐름 제어 (수신자 버퍼 오버플로우 방지), 혼잡 제어 (패킷 수가 과도하게 증가하는 현상 방지)
- 데이터의 손실 발생 시 재전송 지원 (오류 제어)

#### 단점
- UDP에 비해 전송속도가 느림
- 데이터로 보내기 전에 반드시 연결이 형성되어야함
- 한 회선당 1 : 1 통신만 가능
- 고정된 통신 경로가 최단선(네트워크 길이)이 아닐경우 상대적으로 UDP보다 데이터 전송속도가 느림

##### 사용
- SMTP, FTP, SSH, TELNET, HTTP

## 2. UDP
> 비연결 지향적 프로토콜 - 통신을 하기 위해서 두 단말기 사이에 미리 연결이 필요하지 않음
>
> 데이터를 주고받을 때 연결 절차를 거치지 않고 송신자가 일방적으로 데이터를 송신하는 방식
>

#### 특징
- 비연결 지향 프로토콜
- 데이터 그램 단위로 데이터를 분할하여 전송
    - 데이터 경계를 구분함
    - 각각의 데이터그램은 서로 다른 경로로 전송될 수 있음
- 통신 과정에서 송신과 수신 신호절차가 존재하지 않음
- 신뢰성 없는 데이터 전송
- 패킷 관리가 필요함

#### 장점
- 비교적 TCP보다 속도가 빠름
    - 통신을 위한 연결 절차가 존재하지 않음
    - 흐름 · 순서 · 혼잡 제어가 없음
    - Checksum 검사합 외에 특별한 오류 제어가 없음
- 패킷 오버헤드가 적어 네트워크 부하가 감소
- 여러 다수 지점에 전송 가능
- 헤더가 단순함

#### 단점
- 전송이 신뢰성이 없음
    - 데이터그램의 올바른 순서, 도착을 보장하지 않음
- UDP를 사용시, 전체 메시지가 올바른 순서로 도착했는지에 대해 확인할 수 있어야함
- 데이터의 손실이 발생해도 재전송하지 않음
- 데이터를 순서대로 재조립하는 과정이 없음

##### 사용
- DNS, RTP(Real Time Protocol - ex.전화), Multicast

## [2. TCP의 동작]

## 1. TCP 통신 과정

> TCP 프로토콜의 작동은 크게 세가지 흐름으로 구분하는데 다음과 같다.
>
>1. 연결 생성(Connection establishment)
>2. 자료 전송(Data transfer)
>3. 연결 종료(Connection termination)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F9910A8345BB0B75F2A0A82)
*출처 : https://www.crocus.co.kr/1362*

<br/>

### 1. 연결 생성 *3-way handshaking*
> 1. 클라이언트는 접속을 요청하는 SYN 패킷을 보낸다.
>    -  클라이언트는 SYN 패킷을 보냄과 동시에 응답을 기다리기위해 SYN_SENT 상태 전환
><br/><br/>
>2. 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락하는 ACK 패킷과 SYN 패킷 전송
>    - 서버는 SYN_RCVD(SYN_RECEIVED)상태로 변하여 클라이언트가 ACK 패킷을 보낼 때 까지 대기
><br/><br/>
>3. 클라이언트는 서버에 ACK 패킷을 전송
>    - ESTABLISHED 상태가 되어 데이터 통신이 가능

*즉, ACK 패킷의 Acknowledgement Number는 신뢰적 데이터 전송을 위해 사용*<br/>
*ISN **Initialized Sequence Number** 초기 시퀀스 번호 - SYN 패킷의 Sequence Number는 운영체제의 의해서 랜덤하게 생성*<br/>
*동기화 요청에 대한 답신 - 클라이언트의 시퀀스 넘버에 +1을 해서 ack로 리턴*

### 2. 자료 전송
> 1. 송신측에서 window의 크기만큼 data 전송
><br/><br/>
> 2. 수신측에서는 데이터를 받게 되면 ACK로 응답
>       - 송신측에서는 ACK를 보낼 필요가 없음

### 3. 연결 종료 *4-way handshaking*
> 1. 서버와 클라이언트가 TCP 연결이 되어있는 상태에서 클라이언트가 접속을 끊기 위해 FIN segmment 전송
>      - 클라이언트는 FIN_WAIT1 상태로 전환<br/><br/>
> 2. 서버는 CLOSE_WAIT 상태로 바꾼 후 ACK segment를 전송한다.
>      - FIN은 클라이언트가 끊을 것이라는 신호를 받은것이고<br/>
>        CLOSE_WAIT를 통해 자신의 통신이 끝날때까지 대기하는 상태로 전환 <br/><br/>
> 3. ACK segment를 받은 클라이언트는 FIN_WAIT2로 변환<br/><br/>
> 4. 종료 프로세스를 모두 수행한 서버는 FIN segment를 전송하고 LAST_ACK 상태로 전환<br/><br/>
> 5. 서버도 연결을 닫았다는 신호를 클라이언트가 수신하면 <br/>ACK segment를 보낸 후 TIME_WAIT 상태로 전환
> <br/><br/>
>
> 이 후 모든것이 끝나면 CLOSED 상태로 변환
>
> LAST_ACK : 연결은 종료되고 승인을 기다리는 상태

### 비정상 종료 상황
> 서버 or 클라이언트에서 응답을 받지 못해 FIN_WAIT1, FIN_WAIT2, CLOSE_WAIT에서 무한정 대기
>
> CLOSE_WAIT 상태 : FIN segment를 받은 수신 측에서 close 하지 않은 상태
>   -  Socket Hang Up 에러가 발생
>   - 적절한 close 호출 필요
>
> FIN_WAIT1 상태 : 상대방측에 커넥션 종료 요청을 했는데, ACK를 받지 못한 상태로 대기
>   - 시간(Time out)이 지나면 종료됨
>
> FIN_WAIT2 상태 : 서버에서 종료를 완료했다는 FIN 을 받지 못하고 기다리고 있는 상태
>   - 시간(Time out)이 지나면 종료됨

> Q. 3-way handshaking과 4-way handshaking 이 필요한 이유가 뭔가요?
```
TCP는 양방향성 연결이기 때문에 클라이언트에서 서버에게 자신의 존재를 알리고 패킷을 보낼 수 있는 것처럼 
서버에서도 클라이언트에게 자신의 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 하기 때문이다.
```
> Q. 4-way handshaking에서 클라이언트에서 TIME_WAIT가 필요한 이유가 뭔가요?

> Q. HTTP 는 비연결성 특징을 가지는데 어떻게 TCP 기반인가요?

    - HTTP는 클라이언트가 서버와 계속해서 연결을 유지하지 않음
    - 연결 > 응답 > 종료가 한번에 이루어짐


## 2. TCP 통신 특징

> TCP 통신은 흐름제어, 오류제어, 혼잡제어의 기능을 가진다.

### 흐름 제어
> 송신측과 수신측 사이의 데이터 처리 속도 차이(흐름)을 해결하기 위한 기법
>
> 송신측의 전송량 > 수신측의 처리량 => 전송된 패킷은 수신측의 큐를 넘어서 손실될 수 있음(오버플로우)

#### 1. 정지 대기 *Stop & Wait* = Give & Take
- 매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송
- 응답받기 전 다음 데이터를 보낼 수 없기 떄문에 비효율적

#### 2. 슬라이딩 윈도우 *Sliding Window*
- 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여<br/> 데이터 흐름을 동적으로 조절하는 기법
- 송신측에서는 window 크기만큼의 데이터를 보내기 전까지 ACK를 수신받지 않고 연속 전송 가능
    - Stop and Wait의 비효율성을 개선한 기법
```
ex) 슬라이딩 윈도우의 크기가 1 2 3 4 5 6 으로 6일 경우
1. 1 2 데이터를 전송
2. 3 4 데이터를 전송 하였는데, 수신 측에서 ACK를 받은 경우
3. 슬라이딩 윈도우는 5 6 상태를 가지므로 빈 4개의 공간을 확장함
4. 슬라이딩 윈도우는 5 6 x x x x 의 상태를 가지게 됨
```

### 오류 제어

> 오류 검출과 재전송을 포함하는 기능
>
> ARQ *Automatic Repeat Request* 기법을 사용 (흐름제어와 관련있음)
>
> 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구<br/>

1. Stop & Wait ARQ
>- 송신 측에서 1개의 프레임을 송신 - 수신측에서 수신된 프레임의 에러 유무를 판단한 후 ACK(정상) or NAK(오류)를 응답
>- 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0, 1 번호를 번갈아가며 부여
>- 만약 데이터 or ACK가 분실됐을 경우 TimeOut이 발생되며 송신측에서 데이터 재전송
>- 송신측에서 ACK 받을 경우만 다음 데이터 전송
>- 장점 : 구현방법이 단순하고 송신측 내 최대 프레임 크기의 버퍼를 1개만 잡아도 됨
>- 단점 : ACK를 받을 때까지 다음 프레임 전송이 지연되므로 효율이 안좋음

2. Go-Back-N ARQ (=슬라이딩 윈도우=연속적 ARQ)
> - 혼잡제어 기능도 존재
> - 일정한 크기의 이내에서 한번에 여러 패킷을 송신 - 한번의 ACK or NAK 으로 응답
> - 전송된 모든 프레임의 복사본을 가지고 있어야 함 (각각의 ACK or NAK를 확인해야 함)
> - ACK ( 다음 프레임 전송 ) NAK ( 손상된 프레임 자체 번호를 반환 )
> - 수신측은 순서에 맞지 않은 ( 원하지 않은 ) 데이터가 전송될 시, NAK 응답. NAK 이후 데이터 폐기
> - 재전송되는 경우
- NAK 프레임을 받을 경우
>       - 확인된 데이터 이후의 모든 데이터 프레임 재전송 / 수신측은 NAK이후 데이터 폐기
>       - 0 1 2 3 4 의 데이터를 전송 시, 프레임 2가 손실될 시, 수신측에서 NAK2를 송신측으로 응답
>       - 송신측은 프레임 2과 그 이후 프레임들을 모두 재전송
- 프레임 분실
>       - 0 1 2 3 4 의 순서를 가지는 프레임 전송시, 프레임 0 1을 전송 후 2가 손실되고 3, 4가 전송됨
>       - 수신측은 NAK2 를 응답하고 프레임 3, 4를 폐기
>       - 송신측은 프레임 2 3 4 를 재전송
- ACK 프레임 타임아웃
>       - 일정 시간 내의 ACK 응답을 받지 못할 경우 Time Out
>       - 송신측에서 가장 마지막 ACK된 응답부터 재전송 수행

3. SR *Selective-Reject* ARQ
> - GBN ARQ 이 확인된 프레임 이후 모든 프레임을 재전송하는 단점을 보완
> - 손상 · 손실된 프레임만 재전송
> - 별도의 데이터 재정렬을 수행해야 하며, 별도의 버퍼 필요
> - 수신측에 버퍼를 두어 받은 데이터의 정렬이 필요

- 효율이 좋으나 구조가 복잡하고 유지관리 비용이 증가

### 혼잡 제어


## [3. UDP의 구조]

![](https://camo.githubusercontent.com/97937857395944ea8fa05caa629426bed8f78fbfd22c72d5a397b5344bc8609a/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323732413541333835373539323637423336)
